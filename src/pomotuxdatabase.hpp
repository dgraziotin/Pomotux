#ifndef _pomotuxdatabase_hpp_
#define _pomotuxdatabase_hpp_
#include "litesql.hpp"
/**
 * All the classes in the namespace <strong>pomotuxdatabase</strong> are automatically generated by
 * litesql-gen.
 */
namespace pomotuxdatabase {
class Activity;
class ActivityInventorySheet;
class TodoTodaySheet;
class Settings;

/**
 * Relationship class between Activities and Activity Inventory Sheet
 * @see Activity
 * @see ActivityInventorySheet
 * @see http://apps.sourceforge.net/trac/litesql/
 */
class ActivityInAIS {
public:
    /**
     * Represents a Row in the database. <br>
     * One column is an Activity,
     * while the second column is an ais (many to one relationship)
     */
    class Row {
    public:
        litesql::Field<int> activityInventorySheet;
        litesql::Field<int> activity;
        Row(const litesql::Database& db, const litesql::Record& rec=litesql::Record());
    };
    static const std::string table__;
    static const litesql::FieldType Activity;
    static const litesql::FieldType ActivityInventorySheet;
    static void link(const litesql::Database& db, const pomotuxdatabase::Activity& o0, const pomotuxdatabase::ActivityInventorySheet& o1);
    static void unlink(const litesql::Database& db, const pomotuxdatabase::Activity& o0, const pomotuxdatabase::ActivityInventorySheet& o1);
    static void del(const litesql::Database& db, const litesql::Expr& expr=litesql::Expr());
    static litesql::DataSource<ActivityInAIS::Row> getRows(const litesql::Database& db, const litesql::Expr& expr=litesql::Expr());
    template <class T> static litesql::DataSource<T> get(const litesql::Database& db, const litesql::Expr& expr=litesql::Expr(), const litesql::Expr& srcExpr=litesql::Expr());
    ;
    ;
};
/**
 * Relationship class between Activities and Todo Today Sheet.
 * @see Activity
 * @see TodoTodaySheet
 * @see http://apps.sourceforge.net/trac/litesql/
 */
class ActivityInTTS {
public:
    /**
     * Represents a Row in the database. <br>
     * One column is an Activity,
     * while the second column is a tts (many to one relationship)
     */
    class Row {
    public:
        litesql::Field<int> todoTodaySheet;
        litesql::Field<int> activity;
        Row(const litesql::Database& db, const litesql::Record& rec=litesql::Record());
    };
    static const std::string table__;
    static const litesql::FieldType Activity;
    static const litesql::FieldType TodoTodaySheet;
    static void link(const litesql::Database& db, const pomotuxdatabase::Activity& o0, const pomotuxdatabase::TodoTodaySheet& o1);
    static void unlink(const litesql::Database& db, const pomotuxdatabase::Activity& o0, const pomotuxdatabase::TodoTodaySheet& o1);
    static void del(const litesql::Database& db, const litesql::Expr& expr=litesql::Expr());
    static litesql::DataSource<ActivityInTTS::Row> getRows(const litesql::Database& db, const litesql::Expr& expr=litesql::Expr());
    template <class T> static litesql::DataSource<T> get(const litesql::Database& db, const litesql::Expr& expr=litesql::Expr(), const litesql::Expr& srcExpr=litesql::Expr());
    ;
    ;
};
/**
 * Class that describes an Activity.
 * @see http://apps.sourceforge.net/trac/litesql/
 */
class Activity : public litesql::Persistent {
public:
    class Own {
    public:
        static const litesql::FieldType Id;
    };
    static const std::string type__;
    static const std::string table__;
    static const std::string sequence__;
    static const litesql::FieldType Id;
    /**
     * An automatically created attribute to store the id of an Activity
     * in the database
     */
    litesql::Field<int> id;
    static const litesql::FieldType Type;
    litesql::Field<std::string> type;
    static const litesql::FieldType MDescription;
    /**
     * A string that holds the description of an activity
     */
    litesql::Field<std::string> mDescription;
    static const litesql::FieldType MInsertionDate;
    /**
     * The date of the creation of the activity
     */
    litesql::Field<litesql::Date> mInsertionDate;
    static const litesql::FieldType MDeadline;
    /**
     * The deadline of the activity.
     */
    litesql::Field<litesql::Date> mDeadline;
    static const litesql::FieldType MNumPomodoro;
    /**
     * The number of Pomodoro dedicated to the activity
     */
    litesql::Field<int> mNumPomodoro;
    static const litesql::FieldType MOrder;
    /**
     * The order of the activity when scheduled in TTS
     */
    litesql::Field<int> mOrder;
    static const litesql::FieldType MIsFinished;
    /**
     * A boolean representing the status of an Activity
     */
    litesql::Field<bool> mIsFinished;
protected:
    void defaults();
public:
    Activity(const litesql::Database& db);
    Activity(const litesql::Database& db, const litesql::Record& rec);
    Activity(const Activity& obj);
    const Activity& operator=(const Activity& obj);
	/**
     * Converts a Unix date stored in a string to a human readable date (ISO 8601) again as a string. <br/>
	 * This method makes sense using litesql-0.3.3 with Scott McFarland patch against LiteSQL datetime.ccp. <br/>
	 * This method should probably change when litesql-0.3.4 comes out.
     * @see Activity
	 * @see http://apps.sourceforge.net/trac/litesql
	 * @see http://apps.sourceforge.net/trac/litesql/attachment/ticket/13/litesql-0.3.3-time.patch
	 * @see http://en.wikipedia.org/wiki/ISO_8601
	 * @return a ISO 8601 string containing the date (example: 2009-05-11)
     */
    virtual std::string HumanizeDate(std::string unixDate);
	/**
	 * Acts as a getter for Activity::mInsertionDate, as LiteSQL-0.3.3 has some bugs when using the 
	 * public attribute directly. <br/>
	 * The method is just a wrapper for Activity::HumanizeDate(mInsertionDate)
     * @see Activity
	 * @see HumanizeDate
	 * @see http://apps.sourceforge.net/trac/litesql
	 * @see http://apps.sourceforge.net/trac/litesql/attachment/ticket/13/litesql-0.3.3-time.patch
	 * @see http://en.wikipedia.org/wiki/ISO_8601
     */
    virtual std::string GetInsertionDate();
	/**
	 * Acts as a getter for Activity::mDeadline, as LiteSQL-0.3.3 has some bugs when using the 
	 * public attribute directly. <br/>
	 * The method is just a wrapper for Activity::HumanizeDate(mDeadline)
     * @see Activity
	 * @see HumanizeDate
	 * @see http://apps.sourceforge.net/trac/litesql
	 * @see http://apps.sourceforge.net/trac/litesql/attachment/ticket/13/litesql-0.3.3-time.patch
	 * @see http://en.wikipedia.org/wiki/ISO_8601
     */
    virtual std::string GetDeadline();
    /**
     * This method deletes an activity in a clever way. <br/>
     * It searches for the activity in the Activity table, as well as in the corresponding relations
     * ActivityInAIS and ActivityInTTS, deleting it.
     * @param rDatabase a reference to the current database used
     * @param rCurrentActivity a reference to the activity whe want to delete
     * @param rAIS a reference to the current Activity Inventory Sheet
     * @param rTTS a reference to the current Todo Today Sheet
     * @see Activity
     * @see ActivityInventorySheet
     * @see ActivityInAIS
     * @see TodoTodaySheet
     * @see ActivityInTTS
     */
    virtual void Delete(const litesql::Database& rDatabase, Activity& rCurrentActivity, ActivityInventorySheet& rAIS, TodoTodaySheet& rTTS);
    /**
     * This method modifies an existing activity. <br/>
     * We just let the user to modify its description and the deadline.
     * @param rDatabase a reference to the current database used
     * @param rCurrentActivity a reference to the activity whe want to delete
     * @param newDeadline the new deadline
     * @param newDescription the new description
     * @see Activity
     */
    virtual void Modify(const litesql::Database& rDatabase, Activity& rCurrentActivity, int newDeadline, std::string newDescription);
protected:
    std::string insert(litesql::Record& tables, litesql::Records& fieldRecs, litesql::Records& valueRecs);
    void create();
    virtual void addUpdates(Updates& updates);
    virtual void addIDUpdates(Updates& updates);
public:
    static void getFieldTypes(std::vector<litesql::FieldType>& ftypes);
protected:
    virtual void delRecord();
    virtual void delRelations();
public:
    virtual void update();
    virtual void del();
    virtual bool typeIsCorrect();
    std::auto_ptr<Activity> upcast();
    std::auto_ptr<Activity> upcastCopy();
};
std::ostream & operator<<(std::ostream& os, Activity o);
/**
 * Class that describes an Activity Inventory Sheet
 * @see Activity
 * @see http://apps.sourceforge.net/trac/litesql/
 */
class ActivityInventorySheet : public litesql::Persistent {
public:
    class Own {
    public:
        static const litesql::FieldType Id;
    };
    static const std::string type__;
    static const std::string table__;
    static const std::string sequence__;
    static const litesql::FieldType Id;
    /**
     * An automatically created attribute to store the id of an AIS stored in the database
     */
    litesql::Field<int> id;
    static const litesql::FieldType Type;
    litesql::Field<std::string> type;
protected:
    void defaults();
public:
    ActivityInventorySheet(const litesql::Database& db);
    ActivityInventorySheet(const litesql::Database& db, const litesql::Record& rec);
    ActivityInventorySheet(const ActivityInventorySheet& obj);
    const ActivityInventorySheet& operator=(const ActivityInventorySheet& obj);
    /**
     * Method that inserts an Activity in the Activity Inventory Sheet, using ActivityInAIS relation.
     *
     * @param rDatabase a reference to the current database used
     * @param rNewActivity a reference to the activity whe have just created
     * @param rAIS a reference to the current Activity Inventory Sheet
     * @see Activity
     * @see ActivityInAIS
     */
    virtual void InsertActivity(const litesql::Database& rDatabase, Activity& rNewActivity, ActivityInventorySheet& rAIS);
protected:
    std::string insert(litesql::Record& tables, litesql::Records& fieldRecs, litesql::Records& valueRecs);
    void create();
    virtual void addUpdates(Updates& updates);
    virtual void addIDUpdates(Updates& updates);
public:
    static void getFieldTypes(std::vector<litesql::FieldType>& ftypes);
protected:
    virtual void delRecord();
    virtual void delRelations();
public:
    virtual void update();
    virtual void del();
    virtual bool typeIsCorrect();
    std::auto_ptr<ActivityInventorySheet> upcast();
    std::auto_ptr<ActivityInventorySheet> upcastCopy();
};
std::ostream & operator<<(std::ostream& os, ActivityInventorySheet o);
/**
 * Class that describes a Todo Today Sheet
 * @see Activity
 * @see http://apps.sourceforge.net/trac/litesql/
 */
class TodoTodaySheet : public litesql::Persistent {
public:
    class Own {
    public:
        static const litesql::FieldType Id;
    };
    static const std::string type__;
    static const std::string table__;
    static const std::string sequence__;
    static const litesql::FieldType Id;
    /**
     * An automatically generated attribute that stores the id of the object when made persistend
     */
    litesql::Field<int> id;
    static const litesql::FieldType Type;
    litesql::Field<std::string> type;
protected:
    void defaults();
public:
    TodoTodaySheet(const litesql::Database& db);
    TodoTodaySheet(const litesql::Database& db, const litesql::Record& rec);
    TodoTodaySheet(const TodoTodaySheet& obj);
    const TodoTodaySheet& operator=(const TodoTodaySheet& obj);
    /**
     * This method schedules an Activity in the TodoTodaySheet. <br/>
     * It uses the ActivityInTTS relation. <br/>
     * It needs a reference to the actual Activity Inventory Sheet because this method does also a
     * consistency check: the activity MUST be in AIS before going in TTS. It uses ActivityInAIS to
     * perform this operation
     * @param rDatabase a reference to the current database used
     * @param rCurrentActivity a reference to the activity whe want to schedule
     * @param rAIS a reference to the current Activity Inventory Sheet
     * @param rTTS a reference to the current Todo Today Sheet
     * @see Activity
     * @see ActivityInventorySheet
     * @see ActivityInAIS
     * @see TodoTodaySheet
     * @see ActivityInTTS
     */
    virtual void ScheduleActivity(const litesql::Database& rDatabase, Activity& rNewActivity, ActivityInventorySheet& rAIS, TodoTodaySheet& rTTS);
    /**
     * Marks an Activity to be finished. <br/>
     * It unlinks the Activity from a TodoTodaySheet.<br/>
     * Sets its status as "finished"
     * @param rDatabase a reference to the current database used
     * @param rCurrentActivity a reference to the activity whe want to schedule
     * @param rTTS a reference to the current Todo Today Sheet
     * @see Activity
     * @see TodoTodaySheet
     * @see ActivityInTTS
     */
    virtual void FinishActivity(const litesql::Database& rDatabase, Activity& rCurrentActivity, TodoTodaySheet& rTTS);
    /**
     * Unlinks an Activity from a TodoTodaySheet <br/>
     * It unlinks the Activity from the ActivityInTTS relation.<br/>
     * Does not change its status.
     * @param rDatabase a reference to the current database used
     * @param rCurrentActivity a reference to the activity whe want to schedule
     * @param rTTS a reference to the current Todo Today Sheet
     * @see Activity
     * @see TodoTodaySheet
     * @see ActivityInTTS
     */
    virtual void PostponeActivity(const litesql::Database& rDatabase, Activity& rCurrentActivity, TodoTodaySheet& rTTS);
    /**
     * Changes the priority of an Activity.
     *
     * @param rDatabase a reference to the current database used
     * @param rCurrentActivity a reference to the activity whe want to schedule
     * @param rCurrentTTS a reference to the current Todo Today Sheet
     * @param direction the direction of moving (negative for "up", positive for "down")
     * @see Activity
     * @see TodoTodaySheet
     * @see ActivityInTTS
     */
    virtual void MoveActivity(const litesql::Database& rDatabase, Activity& rCurrentActivity, TodoTodaySheet& rCurrentTDS, const int direction);
    /**
     * Returns the max value of order of the activities scheduled in TTS.
     *
     * @param rDatabase a reference to the current database used
     * @param rCurrentTTS a reference to the current Todo Today Sheet
     * @return the max value of order
     * @see Activity
     * @see TodoTodaySheet
     * @see ActivityInTTS
     */
    virtual int GetMaxActivityOrder(const litesql::Database& rDatabase, TodoTodaySheet& rTTS);
    /**
     * Tries to make consistent the values of orders of the activities scheduled in the TTS.<br/>
     * It fetches the activities scheduled in the TTS, ordered by "mOrder". <br/>
     * The sequence could be fragmented, ie. 1-2-4-7-8-9-15-17. <br/>
     * The method updates the orders to be sequential, ie. 1-2-3-4-5-6-7-8. <br/>
     *
     * @param rDatabase a reference to the current database used
     * @param rCurrentTTS a reference to the current Todo Today Sheet
     * @see Activity
     * @see TodoTodaySheet
     * @see ActivityInTTS
     */
    virtual void MakeConsistent(const litesql::Database& rDatabase, TodoTodaySheet& rTTS);
protected:
    std::string insert(litesql::Record& tables, litesql::Records& fieldRecs, litesql::Records& valueRecs);
    void create();
    virtual void addUpdates(Updates& updates);
    virtual void addIDUpdates(Updates& updates);
public:
    static void getFieldTypes(std::vector<litesql::FieldType>& ftypes);
protected:
    virtual void delRecord();
    virtual void delRelations();
public:
    virtual void update();
    virtual void del();
    virtual bool typeIsCorrect();
    std::auto_ptr<TodoTodaySheet> upcast();
    std::auto_ptr<TodoTodaySheet> upcastCopy();
};
std::ostream & operator<<(std::ostream& os, TodoTodaySheet o);

/**
 * Holds settings of a single user
 * @see http://apps.sourceforge.net/trac/litesql/
 */
class Settings : public litesql::Persistent {
public:
    class Own {
    public:
        static const litesql::FieldType Id;
    };
    static const std::string type__;
    static const std::string table__;
    static const std::string sequence__;
    static const litesql::FieldType Id;
	/**
     * An automatically generated attribute that stores the id of the option
     */
    litesql::Field<int> id;
    static const litesql::FieldType Type;
    litesql::Field<std::string> type;
    static const litesql::FieldType MName;
	/**
     * Stores the name of the option field we want to memorize
     */
    litesql::Field<std::string> mName;
    static const litesql::FieldType MValue;
	/**
     * Stores the value of the option field
     */
    litesql::Field<std::string> mValue;
protected:
    void defaults();
public:
    Settings(const litesql::Database& db);
    Settings(const litesql::Database& db, const litesql::Record& rec);
    Settings(const Settings& obj);
    const Settings& operator=(const Settings& obj);
protected:
    std::string insert(litesql::Record& tables, litesql::Records& fieldRecs, litesql::Records& valueRecs);
    void create();
    virtual void addUpdates(Updates& updates);
    virtual void addIDUpdates(Updates& updates);
public:
    static void getFieldTypes(std::vector<litesql::FieldType>& ftypes);
protected:
    virtual void delRecord();
    virtual void delRelations();
public:
    virtual void update();
    virtual void del();
    virtual bool typeIsCorrect();
    std::auto_ptr<Settings> upcast();
    std::auto_ptr<Settings> upcastCopy();
};
std::ostream & operator<<(std::ostream& os, Settings o);
/**
 * This class describes a Pomotux Database
 * @see http://apps.sourceforge.net/trac/litesql/
 */
class PomotuxDatabase : public litesql::Database {
public:
    PomotuxDatabase(std::string backendType, std::string connInfo);
protected:
    virtual std::vector<litesql::Database::SchemaItem> getSchema() const;
    static void initialize();
};
}
#endif
